
import React, { useState } from 'react';
import { Plus, Trash2, Save, Database, Video, LayoutGrid, Loader2, ChevronDown, ChevronRight, X, Tag, RefreshCw } from 'lucide-react';
import { CatalogCategory, CatalogVideo, VideoCategoryRef } from '../types';
import { supabase } from '../supabaseClient';
import { INITIAL_CATALOG_CATEGORIES, INITIAL_CATALOG_VIDEOS } from '../constants';

interface CatalogManagerProps {
  categories: CatalogCategory[];
  videos: CatalogVideo[];
  onSave: () => void;
}

const CatalogManager: React.FC<CatalogManagerProps> = ({ categories, videos, onSave }) => {
  const [isSaving, setIsSaving] = useState(false);
  
  // Category State
  const [newCategory, setNewCategory] = useState('');
  const [expandedCategory, setExpandedCategory] = useState<string | null>(null);
  
  // Subcategory State (Local state for input)
  const [newSubcategoryLabel, setNewSubcategoryLabel] = useState('');
  const [activeSubcatInputId, setActiveSubcatInputId] = useState<string | null>(null);

  // Video State
  const [newVideo, setNewVideo] = useState<Partial<CatalogVideo>>({
      title: '', description: '', video_url: '', category_refs: []
  });
  
  const repairSql = `
-- 1. Создание/Исправление таблицы категорий
CREATE TABLE IF NOT EXISTS public.catalog_categories_shibari (
    id text PRIMARY KEY,
    label text,
    subcategories jsonb DEFAULT '[]'::jsonb,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now())
);

-- 2. Создание/Исправление таблицы видео
CREATE TABLE IF NOT EXISTS public.catalog_videos_shibari (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    title text,
    description text,
    video_url text,
    category_refs jsonb DEFAULT '[]'::jsonb,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now())
);

-- 3. Добавление колонок если таблицы существовали, но были старыми
ALTER TABLE public.catalog_videos_shibari ADD COLUMN IF NOT EXISTS category_refs jsonb DEFAULT '[]'::jsonb;
ALTER TABLE public.catalog_categories_shibari ADD COLUMN IF NOT EXISTS subcategories jsonb DEFAULT '[]'::jsonb;

-- 4. Права доступа
ALTER TABLE public.catalog_categories_shibari ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.catalog_videos_shibari ENABLE ROW LEVEL SECURITY;

DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE tablename = 'catalog_categories_shibari' AND policyname = 'Allow all') THEN
    CREATE POLICY "Allow all" ON public.catalog_categories_shibari FOR ALL USING (true) WITH CHECK (true);
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE tablename = 'catalog_videos_shibari' AND policyname = 'Allow all') THEN
    CREATE POLICY "Allow all" ON public.catalog_videos_shibari FOR ALL USING (true) WITH CHECK (true);
  END IF;
END $$;
  `.trim();

  const handleSeed = async () => {
      if (!window.confirm("Это сбросит каталог к базовому состоянию (3 видео). Продолжить?")) return;
      setIsSaving(true);
      try {
          if (!supabase) throw new Error("No DB");
          
          // Clear existing
          await supabase.from('catalog_videos_shibari').delete().neq('id', 0);
          await supabase.from('catalog_categories_shibari').delete().neq('id', '0');

          const { error: catError } = await supabase.from('catalog_categories_shibari').insert(INITIAL_CATALOG_CATEGORIES);
          if (catError) throw catError;

          // Remove IDs to auto-generate
          const videosToInsert = INITIAL_CATALOG_VIDEOS.map(({ id, ...rest }) => rest);
          const { error: vidError } = await supabase.from('catalog_videos_shibari').insert(videosToInsert);
          if (vidError) throw vidError;

          alert("Каталог сброшен!");
          onSave();
      } catch (e: any) {
          console.error(e);
          alert(`Ошибка инициализации: ${e.message}\n\nВозможно, нужно обновить структуру БД. Скопируйте SQL ниже в Supabase SQL Editor:\n\n${repairSql}`);
      } finally {
          setIsSaving(false);
      }
  };

  const handleGenerateRandom = async () => {
      if (!window.confirm("Создать 100 случайных видео? Таблица видео будет очищена.")) return;
      setIsSaving(true);
      try {
          if (!supabase) throw new Error("No DB");
          
          // 1. Clean Videos
          await supabase.from('catalog_videos_shibari').delete().neq('id', 0);

          // 2. Generate Data
          const prefixes = ['Kinbaku', 'Shibari', 'Semenawa', 'Hojojutsu', 'Gishiki', 'Nawashi', 'Karada', 'Teppo', 'Agura', 'Takate Kote', 'Futomomo', 'Ichinawa'];
          const suffixes = ['Technique', 'Practice', 'Flow', 'Safety', 'Review', 'Demo', 'Lab', 'Masterclass'];
          const descTerms = ['anatomy', 'rope handling', 'suspension safety', 'floorwork aesthetics', 'knot theory'];
          const videoUrl = 'https://www.youtube.com/watch?v=f7uVUa2_y1k';

          const newVideos: any[] = [];
          
          for (let i = 0; i < 100; i++) {
              const title = `${prefixes[Math.floor(Math.random() * prefixes.length)]} : ${suffixes[Math.floor(Math.random() * suffixes.length)]}`;
              const description = `This is a detailed video lesson covering ${descTerms[Math.floor(Math.random() * descTerms.length)]}.`;
              
              // Generate refs based on CURRENT categories in state
              const refs = categories.map(cat => {
                  const subs = cat.subcategories || [];
                  if (subs.length === 0) return null;
                  const randomSub = subs[Math.floor(Math.random() * subs.length)];
                  return {
                      categoryId: cat.id,
                      subcategoryId: randomSub.id
                  };
              }).filter(Boolean);

              newVideos.push({
                  title,
                  description,
                  video_url: videoUrl,
                  category_refs: refs
              });
          }

          // 3. Insert in chunks of 50 to avoid payload limits
          const chunkSize = 50;
          for (let i = 0; i < newVideos.length; i += chunkSize) {
              const chunk = newVideos.slice(i, i + chunkSize);
              const { error } = await supabase.from('catalog_videos_shibari').insert(chunk);
              if (error) throw error;
          }
          
          alert("100 видео успешно создано!");
          onSave();
      } catch (e: any) {
          console.error(e);
          alert(`Ошибка: ${e.message}\n\nЕсли ошибка 'column does not exist', выполните этот SQL:\n\n${repairSql}`);
      } finally {
          setIsSaving(false);
      }
  };

  const handleAddCategory = async () => {
      if (!newCategory.trim()) return;
      setIsSaving(true);
      try {
          const id = Math.random().toString(36).substr(2, 9);
          if (supabase) {
              await supabase.from('catalog_categories_shibari').insert([{ 
                  id, 
                  label: newCategory,
                  subcategories: [] 
              }]);
              setNewCategory('');
              onSave();
          }
      } catch (e) { alert("Ошибка добавления категории"); }
      finally { setIsSaving(false); }
  };

  const handleDeleteCategory = async (id: string) => {
      if (!window.confirm("Удалить категорию?")) return;
      setIsSaving(true);
      try {
          if (supabase) {
              await supabase.from('catalog_categories_shibari').delete().eq('id', id);
              onSave();
          }
      } catch (e) { alert("Ошибка удаления"); }
      finally { setIsSaving(false); }
  };

  const handleAddSubcategory = async (category: CatalogCategory) => {
      if (!newSubcategoryLabel.trim()) return;
      setIsSaving(true);
      try {
          const newSubId = `${category.id}-${Math.random().toString(36).substr(2, 5)}`;
          const updatedSubs = [...(category.subcategories || []), { id: newSubId, label: newSubcategoryLabel }];
          
          if (supabase) {
              await supabase
                .from('catalog_categories_shibari')
                .update({ subcategories: updatedSubs })
                .eq('id', category.id);
              
              setNewSubcategoryLabel('');
              onSave();
          }
      } catch (e) { alert("Ошибка добавления подкатегории"); }
      finally { setIsSaving(false); }
  };

  const handleDeleteSubcategory = async (category: CatalogCategory, subId: string) => {
      if (!window.confirm("Удалить подкатегорию?")) return;
      setIsSaving(true);
      try {
          const updatedSubs = (category.subcategories || []).filter(s => s.id !== subId);
          if (supabase) {
              await supabase
                .from('catalog_categories_shibari')
                .update({ subcategories: updatedSubs })
                .eq('id', category.id);
              onSave();
          }
      } catch (e) { alert("Ошибка удаления"); }
      finally { setIsSaving(false); }
  };

  // --- New Logic for Auto-Mapping Categories ---

  const handleCategorySelectionChange = (categoryId: string, subId: string) => {
      setNewVideo(prev => {
          // Remove existing entry for this category
          const currentRefs = prev.category_refs || [];
          const filteredRefs = currentRefs.filter(r => r.categoryId !== categoryId);

          if (!subId) {
              // If user selected empty value, just remove the ref
              return { ...prev, category_refs: filteredRefs };
          } else {
              // Add/Update the ref
              return { 
                  ...prev, 
                  category_refs: [...filteredRefs, { categoryId, subcategoryId: subId }]
              };
          }
      });
  };

  const handleAddVideo = async () => {
      if (!newVideo.title || !newVideo.video_url) {
          alert("Заполните название и ссылку на видео");
          return;
      }
      setIsSaving(true);
      try {
          if (supabase) {
              const payload = {
                  title: newVideo.title,
                  description: newVideo.description,
                  video_url: newVideo.video_url,
                  category_refs: newVideo.category_refs
              };
              await supabase.from('catalog_videos_shibari').insert([payload]);
              setNewVideo({ title: '', description: '', video_url: '', category_refs: [] });
              onSave();
          }
      } catch (e) { alert("Ошибка добавления видео"); }
      finally { setIsSaving(false); }
  };

  const handleDeleteVideo = async (id: number) => {
      if (!window.confirm("Удалить видео?")) return;
      setIsSaving(true);
      try {
          if (supabase) {
              await supabase.from('catalog_videos_shibari').delete().eq('id', id);
              onSave();
          }
      } catch (e) { alert("Ошибка удаления"); }
      finally { setIsSaving(false); }
  };

  return (
    <div className="space-y-8">
        <div className="flex justify-between items-center bg-neutral-900/50 p-4 rounded-xl border border-neutral-800">
            <div>
                <p className="text-white font-bold">Управление каталогом</p>
                <p className="text-neutral-500 text-sm">Категории, подкатегории и контент.</p>
            </div>
            <div className="flex gap-2">
                <button 
                    onClick={handleGenerateRandom}
                    disabled={isSaving}
                    className="bg-neutral-800 hover:bg-neutral-700 text-yellow-500 hover:text-yellow-400 px-4 py-2 rounded-lg font-bold flex items-center gap-2 transition-colors border border-neutral-700 text-sm"
                    title="Создать 100 видео со случайными категориями"
                >
                    {isSaving ? <Loader2 className="w-4 h-4 animate-spin"/> : <RefreshCw className="w-4 h-4" />} 
                    Генератор 100 Видео
                </button>
                <button 
                    onClick={handleSeed}
                    disabled={isSaving}
                    className="bg-neutral-800 hover:bg-neutral-700 text-neutral-300 px-4 py-2 rounded-lg font-medium flex items-center gap-2 transition-colors border border-neutral-700 text-sm"
                >
                    {isSaving ? <Loader2 className="w-4 h-4 animate-spin"/> : <Database className="w-4 h-4" />} 
                    Сброс (Базовый)
                </button>
            </div>
        </div>

        <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
            {/* Categories & Subcategories Tree */}
            <div className="bg-neutral-900 border border-neutral-800 rounded-xl p-6 flex flex-col h-[600px]">
                <h3 className="font-bold text-white mb-4 flex items-center gap-2"><LayoutGrid className="w-5 h-5 text-red-500"/> Структура каталога</h3>
                
                {/* Add Category */}
                <div className="flex gap-2 mb-4 shrink-0">
                    <input 
                        value={newCategory}
                        onChange={e => setNewCategory(e.target.value)}
                        placeholder="Новая категория"
                        className="flex-1 bg-neutral-800 border border-neutral-700 rounded px-3 py-2 text-sm text-white outline-none"
                    />
                    <button onClick={handleAddCategory} disabled={isSaving} className="bg-red-700 hover:bg-red-600 text-white p-2 rounded"><Plus className="w-5 h-5"/></button>
                </div>

                {/* Tree List */}
                <div className="flex-1 overflow-y-auto space-y-2 pr-2">
                    {categories.map(c => {
                        const isExpanded = expandedCategory === c.id;
                        const subCount = c.subcategories?.length || 0;

                        return (
                            <div key={c.id} className="bg-black/30 rounded border border-neutral-800 overflow-hidden">
                                {/* Category Header */}
                                <div className="flex justify-between items-center p-2 hover:bg-neutral-800/50 transition-colors">
                                    <button 
                                        onClick={() => {
                                            setExpandedCategory(isExpanded ? null : c.id);
                                            setActiveSubcatInputId(null);
                                        }}
                                        className="flex items-center gap-2 text-sm text-white font-bold flex-1 text-left"
                                    >
                                        {isExpanded ? <ChevronDown className="w-4 h-4 text-neutral-500"/> : <ChevronRight className="w-4 h-4 text-neutral-500"/>}
                                        {c.label}
                                        <span className="text-[10px] text-neutral-600 font-normal ml-2">({subCount} sub)</span>
                                    </button>
                                    <button onClick={() => handleDeleteCategory(c.id)} className="text-neutral-600 hover:text-red-500 p-1"><Trash2 className="w-4 h-4"/></button>
                                </div>

                                {/* Subcategories Body */}
                                {isExpanded && (
                                    <div className="bg-neutral-900/50 p-2 border-t border-neutral-800 ml-4 border-l-2 border-l-neutral-800">
                                        {(c.subcategories || []).map(s => (
                                            <div key={s.id} className="flex justify-between items-center py-1 pl-2 hover:bg-neutral-800 rounded mb-1">
                                                <span className="text-xs text-neutral-300">↳ {s.label}</span>
                                                <button onClick={() => handleDeleteSubcategory(c, s.id)} className="text-neutral-700 hover:text-red-500 p-1"><Trash2 className="w-3 h-3"/></button>
                                            </div>
                                        ))}
                                        
                                        {/* Add Subcategory Input */}
                                        <div className="flex gap-2 mt-2 pl-2">
                                            <input 
                                                value={activeSubcatInputId === c.id ? newSubcategoryLabel : ''}
                                                onChange={e => {
                                                    setActiveSubcatInputId(c.id);
                                                    setNewSubcategoryLabel(e.target.value);
                                                }}
                                                placeholder="Добавить подкатегорию..."
                                                className="flex-1 bg-neutral-950 border border-neutral-700 rounded px-2 py-1 text-xs text-white outline-none"
                                                onKeyDown={(e) => {
                                                    if(e.key === 'Enter') handleAddSubcategory(c);
                                                }}
                                            />
                                            <button onClick={() => handleAddSubcategory(c)} className="text-neutral-400 hover:text-white p-1 bg-neutral-800 rounded"><Plus className="w-3 h-3"/></button>
                                        </div>
                                    </div>
                                )}
                            </div>
                        );
                    })}
                </div>
            </div>

            {/* Video Form */}
            <div className="bg-neutral-900 border border-neutral-800 rounded-xl p-6 h-[600px] flex flex-col">
                <h3 className="font-bold text-white mb-4 flex items-center gap-2"><Video className="w-5 h-5 text-red-500"/> Добавить видео</h3>
                <div className="flex flex-col h-full gap-4">
                    <div className="space-y-3 shrink-0">
                        <input 
                            value={newVideo.title}
                            onChange={e => setNewVideo({...newVideo, title: e.target.value})}
                            placeholder="Название видео"
                            className="w-full bg-neutral-800 border border-neutral-700 rounded px-3 py-2 text-sm text-white outline-none"
                        />
                        <input 
                            value={newVideo.description}
                            onChange={e => setNewVideo({...newVideo, description: e.target.value})}
                            placeholder="Описание"
                            className="w-full bg-neutral-800 border border-neutral-700 rounded px-3 py-2 text-sm text-white outline-none"
                        />
                        <input 
                            value={newVideo.video_url}
                            onChange={e => setNewVideo({...newVideo, video_url: e.target.value})}
                            placeholder="Ссылка (YouTube)"
                            className="w-full bg-neutral-800 border border-neutral-700 rounded px-3 py-2 text-sm text-white outline-none"
                        />
                    </div>
                    
                    {/* Categories Grid - Always Visible */}
                    <div className="flex-1 bg-black/30 p-4 rounded-lg border border-neutral-800 overflow-y-auto">
                        <label className="text-[10px] uppercase text-neutral-500 font-bold mb-3 block sticky top-0 bg-neutral-900/90 py-1 z-10 backdrop-blur-sm">
                            Категоризация
                        </label>
                        <div className="grid grid-cols-1 gap-2">
                            {categories.map(cat => {
                                const currentRef = newVideo.category_refs?.find(r => r.categoryId === cat.id);
                                const currentVal = currentRef?.subcategoryId || "";

                                return (
                                    <div key={cat.id} className="flex items-center justify-between gap-2 bg-neutral-900/50 p-2 rounded border border-white/5 hover:border-white/20 transition-colors">
                                        <span className="text-xs text-neutral-300 font-medium w-1/3 truncate" title={cat.label}>{cat.label}</span>
                                        <select
                                            value={currentVal}
                                            onChange={(e) => handleCategorySelectionChange(cat.id, e.target.value)}
                                            className="flex-1 bg-neutral-800 border border-neutral-700 rounded px-2 py-1 text-xs text-white outline-none focus:border-red-600 cursor-pointer"
                                        >
                                            <option value="">-- Не выбрано --</option>
                                            {cat.subcategories?.map(sub => (
                                                <option key={sub.id} value={sub.id}>{sub.label}</option>
                                            ))}
                                        </select>
                                    </div>
                                )
                            })}
                             {categories.length === 0 && <p className="text-xs text-neutral-500 text-center py-4">Создайте категории слева</p>}
                        </div>
                    </div>

                    <button onClick={handleAddVideo} disabled={isSaving} className="w-full bg-red-700 hover:bg-red-600 text-white py-3 rounded font-bold text-sm shrink-0">Добавить видео в каталог</button>
                </div>
            </div>
        </div>

        {/* Video List */}
        <div className="bg-neutral-900 border border-neutral-800 rounded-xl p-6">
            <h3 className="font-bold text-white mb-4">Список видео в каталоге ({videos.length})</h3>
            <div className="space-y-2 max-h-96 overflow-y-auto">
                {videos.map(v => {
                    const refs = v.category_refs || [];
                    
                    return (
                        <div key={v.id} className="flex justify-between items-center bg-black/30 p-3 rounded border border-neutral-800 hover:border-neutral-700">
                            <div>
                                <div className="font-bold text-sm text-white">{v.title}</div>
                                <div className="text-xs text-neutral-500 flex flex-wrap items-center gap-2 mt-1">
                                    {refs.length > 0 ? refs.map((ref, idx) => {
                                         const cat = categories.find(c => c.id === ref.categoryId);
                                         const sub = cat?.subcategories?.find(s => s.id === ref.subcategoryId);
                                         return (
                                             <span key={idx} className="bg-neutral-800 px-1.5 py-0.5 rounded flex items-center gap-1 border border-white/5">
                                                 <span className="text-neutral-500">{cat?.label}:</span>
                                                 <span className="text-white font-medium">{sub?.label}</span>
                                             </span>
                                         );
                                    }) : (
                                        <span className="text-neutral-600 italic">Без категорий</span>
                                    )}
                                </div>
                            </div>
                            <button onClick={() => handleDeleteVideo(v.id)} className="text-neutral-600 hover:text-red-500 p-2"><Trash2 className="w-4 h-4"/></button>
                        </div>
                    );
                })}
                {videos.length === 0 && <p className="text-neutral-500 text-sm">Каталог пуст.</p>}
            </div>
        </div>
    </div>
  );
};

export default CatalogManager;
